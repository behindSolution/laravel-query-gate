<?php

namespace BehindSolution\LaravelQueryGate\TypeScript;

use Illuminate\Support\Str;

class TypesGenerator
{
    /**
     * Generate TypeScript content for a model definition.
     *
     * @param string $modelClass
     * @param array<string, mixed> $definition
     * @param string|null $version
     * @return string
     */
    public function generate(string $modelClass, array $definition, ?string $version = null): string
    {
        $alias = $definition['alias'] ?? $this->classToAlias($modelClass);
        $pascalAlias = Str::studly($alias);

        return $this->buildContent($pascalAlias, $alias, $definition, $version);
    }

    /**
     * Convert a model class name to an alias.
     */
    protected function classToAlias(string $class): string
    {
        $basename = class_basename($class);

        return Str::snake(Str::plural($basename));
    }

    /**
     * Build the TypeScript file content.
     *
     * @param string $pascal
     * @param string $alias
     * @param array<string, mixed> $definition
     * @param string|null $version
     * @return string
     */
    protected function buildContent(string $pascal, string $alias, array $definition, ?string $version): string
    {
        $lines = [];
        $lines[] = "// {$alias}.ts";
        $lines[] = '// Auto-generated by Laravel QueryGate - DO NOT EDIT';

        if ($version !== null) {
            $lines[] = "// Version: {$version}";
        }

        $lines[] = '';

        // Filters interface
        if (!empty($definition['filters'])) {
            $lines[] = $this->generateFiltersInterface($pascal, $definition['filters']);
        }

        // Operators interface
        if (!empty($definition['filter_operators'])) {
            $lines[] = $this->generateOperatorsInterface($pascal, $definition['filter_operators']);
        }

        // Select type
        if (!empty($definition['select'])) {
            $lines[] = $this->generateSelectType($pascal, $definition['select']);
        }

        // Sort type
        if (!empty($definition['sorts'])) {
            $lines[] = $this->generateSortType($pascal, $definition['sorts']);
        }

        // Actions interface
        if (!empty($definition['actions'])) {
            $lines[] = $this->generateActionsInterface($pascal, $definition['actions']);
        }

        // Config object
        $lines[] = $this->generateConfigObject($alias, $definition, $version);

        return implode("\n", array_filter($lines, fn ($line) => $line !== null));
    }

    /**
     * Generate the filters interface.
     *
     * @param string $pascal
     * @param array<string, array<int, string>> $filters
     * @return string
     */
    protected function generateFiltersInterface(string $pascal, array $filters): string
    {
        $lines = [];
        $lines[] = "/** Filterable fields for {$pascal} */";
        $lines[] = "export interface {$pascal}Filters {";

        foreach ($filters as $field => $rules) {
            $tsType = $this->phpRulesToTypeScriptType($rules);
            $lines[] = "  {$field}?: {$tsType}";
        }

        $lines[] = '}';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Generate the operators interface.
     *
     * @param string $pascal
     * @param array<string, array<int, string>> $operators
     * @return string
     */
    protected function generateOperatorsInterface(string $pascal, array $operators): string
    {
        $lines = [];
        $lines[] = "/** Allowed operators per field */";
        $lines[] = "export interface {$pascal}Operators {";

        foreach ($operators as $field => $ops) {
            $opsString = implode(' | ', array_map(fn ($op) => "'{$op}'", $ops));
            $lines[] = "  {$field}: ({$opsString})[]";
        }

        $lines[] = '}';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Generate the select type.
     *
     * @param string $pascal
     * @param array<int, string> $select
     * @return string
     */
    protected function generateSelectType(string $pascal, array $select): string
    {
        $fieldsString = implode(' | ', array_map(fn ($field) => "'{$field}'", $select));

        return "/** Selectable fields */\nexport type {$pascal}SelectField = {$fieldsString}\n";
    }

    /**
     * Generate the sort type.
     *
     * @param string $pascal
     * @param array<int, string> $sorts
     * @return string
     */
    protected function generateSortType(string $pascal, array $sorts): string
    {
        $fieldsString = implode(' | ', array_map(fn ($field) => "'{$field}'", $sorts));

        return "/** Sortable fields */\nexport type {$pascal}SortField = {$fieldsString}\n";
    }

    /**
     * Generate the actions interface.
     *
     * @param string $pascal
     * @param array<string, array<string, mixed>> $actions
     * @return string
     */
    protected function generateActionsInterface(string $pascal, array $actions): string
    {
        $lines = [];
        $lines[] = "/** Available actions */";
        $lines[] = "export interface {$pascal}Actions {";

        foreach ($actions as $action => $config) {
            $method = $config['method'] ?? 'POST';
            $lines[] = "  {$action}: { method: '{$method}' }";
        }

        $lines[] = '}';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Generate the config object.
     *
     * @param string $alias
     * @param array<string, mixed> $definition
     * @param string|null $version
     * @return string
     */
    protected function generateConfigObject(string $alias, array $definition, ?string $version): string
    {
        $lines = [];
        $lines[] = '/** Resource configuration metadata */';
        $lines[] = "export const {$this->toCamelCase($alias)}Config = {";
        $lines[] = "  alias: '{$alias}',";

        // Filters
        if (!empty($definition['filters'])) {
            $filterFields = array_keys($definition['filters']);
            $filtersString = implode(', ', array_map(fn ($f) => "'{$f}'", $filterFields));
            $lines[] = "  filters: [{$filtersString}],";
        }

        // Operators
        if (!empty($definition['filter_operators'])) {
            $lines[] = '  operators: {';
            foreach ($definition['filter_operators'] as $field => $ops) {
                $opsString = implode(', ', array_map(fn ($op) => "'{$op}'", $ops));
                $lines[] = "    {$field}: [{$opsString}],";
            }
            $lines[] = '  },';
        }

        // Selects
        if (!empty($definition['select'])) {
            $selectsString = implode(', ', array_map(fn ($s) => "'{$s}'", $definition['select']));
            $lines[] = "  selects: [{$selectsString}],";
        }

        // Sorts
        if (!empty($definition['sorts'])) {
            $sortsString = implode(', ', array_map(fn ($s) => "'{$s}'", $definition['sorts']));
            $lines[] = "  sorts: [{$sortsString}],";
        }

        // Pagination
        $paginationMode = $definition['pagination']['mode'] ?? 'classic';
        $lines[] = "  pagination: '{$paginationMode}',";

        // Version
        if ($version !== null) {
            $lines[] = "  version: '{$version}',";
        }

        $lines[] = '} as const';
        $lines[] = '';

        return implode("\n", $lines);
    }

    /**
     * Convert PHP validation rules to TypeScript type.
     *
     * @param array<int, string> $rules
     * @return string
     */
    protected function phpRulesToTypeScriptType(array $rules): string
    {
        foreach ($rules as $rule) {
            $rule = strtolower($rule);

            if (in_array($rule, ['integer', 'int', 'numeric'], true)) {
                return 'number';
            }

            if (in_array($rule, ['boolean', 'bool'], true)) {
                return 'boolean';
            }

            if (in_array($rule, ['array'], true)) {
                return 'unknown[]';
            }

            if (in_array($rule, ['date', 'date_format'], true)) {
                return 'string';
            }
        }

        return 'string';
    }

    /**
     * Convert a string to camelCase.
     */
    protected function toCamelCase(string $value): string
    {
        return Str::camel($value);
    }
}
